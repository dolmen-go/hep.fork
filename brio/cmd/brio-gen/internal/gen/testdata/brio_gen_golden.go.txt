// Code generated by brio-gen; DO NOT EDIT.

package pkg

import (
	"encoding/binary"
	"math"
)

// MarshalBinary implements encoding.BinaryMarshaler
func (o *T1) MarshalBinary() (data []byte, err error) {
	var buf [8]byte
	switch o.b {
	case false:
		data = append(data, uint8(0))
	default:
		data = append(data, uint8(1))
	}
	binary.LittleEndian.PutUint64(buf[:8], uint64(o.u))
	data = append(data, buf[:8]...)
	data = append(data, byte(o.u8))
	binary.LittleEndian.PutUint16(buf[:2], uint16(o.u16))
	data = append(data, buf[:2]...)
	binary.LittleEndian.PutUint32(buf[:4], uint32(o.u32))
	data = append(data, buf[:4]...)
	binary.LittleEndian.PutUint64(buf[:8], uint64(o.u64))
	data = append(data, buf[:8]...)
	binary.LittleEndian.PutUint64(buf[:8], uint64(o.i))
	data = append(data, buf[:8]...)
	data = append(data, byte(o.i8))
	binary.LittleEndian.PutUint16(buf[:2], uint16(o.i16))
	data = append(data, buf[:2]...)
	binary.LittleEndian.PutUint32(buf[:4], uint32(o.i32))
	data = append(data, buf[:4]...)
	binary.LittleEndian.PutUint64(buf[:8], uint64(o.i64))
	data = append(data, buf[:8]...)
	binary.LittleEndian.PutUint32(buf[:4], math.Float32bits(o.f32))
	data = append(data, buf[:4]...)
	binary.LittleEndian.PutUint64(buf[:8], math.Float64bits(o.f64))
	data = append(data, buf[:8]...)
	binary.LittleEndian.PutUint64(buf[:4], math.Float32bits(real(o.c64)))
	data = append(data, buf[:4]...)
	binary.LittleEndian.PutUint64(buf[:4], math.Float32bits(imag(o.c64)))
	data = append(data, buf[:4]...)
	binary.LittleEndian.PutUint64(buf[:8], math.Float64bits(real(o.c128)))
	data = append(data, buf[:8]...)
	binary.LittleEndian.PutUint64(buf[:8], math.Float64bits(imag(o.c128)))
	data = append(data, buf[:8]...)
	binary.LittleEndian.PutUint64(buf[:8], uint64(len(o.str)))
	data = append(data, buf[:8]...)
	data = append(data, []byte(o.str)...)
	binary.LittleEndian.PutUint32(buf[:4], uint32(o.rune))
	data = append(data, buf[:4]...)
	binary.LittleEndian.PutUint64(buf[:8], uint64(len(o.bs)))
	data = append(data, buf[:8]...)
	data = append(data, o.bs...)
	for i := range o.arri64 {
		o := &o.arri64[i]
		binary.LittleEndian.PutUint64(buf[:8], uint64(o))
		data = append(data, buf[:8]...)
	}
	for i := range o.arrTime {
		o := &o.arrTime[i]
		{
			sub, err := o.MarshalBinary()
			if err != nil {
				return nil, err
			}
			binary.LittleEndian.PutUint64(buf[:8], uint64(len(sub)))
			data = append(data, buf[:8]...)
			data = append(data, sub...)
		}
	}
	binary.LittleEndian.PutUint64(buf[:8], uint64(len(o.slii64)))
	data = append(data, buf[:8]...)
	for i := range o.slii64 {
		o := &o.slii64[i]
		binary.LittleEndian.PutUint64(buf[:8], uint64(o))
		data = append(data, buf[:8]...)
	}
	binary.LittleEndian.PutUint64(buf[:8], uint64(len(o.sliTime)))
	data = append(data, buf[:8]...)
	for i := range o.sliTime {
		o := &o.sliTime[i]
		{
			sub, err := o.MarshalBinary()
			if err != nil {
				return nil, err
			}
			binary.LittleEndian.PutUint64(buf[:8], uint64(len(sub)))
			data = append(data, buf[:8]...)
			data = append(data, sub...)
		}
	}
	{
		v := *o.ptri64
		binary.LittleEndian.PutUint64(buf[:8], uint64(v))
		data = append(data, buf[:8]...)
	}
	{
		sub, err := o.t2.MarshalBinary()
		if err != nil {
			return nil, err
		}
		binary.LittleEndian.PutUint64(buf[:8], uint64(len(sub)))
		data = append(data, buf[:8]...)
		data = append(data, sub...)
	}
	binary.LittleEndian.PutUint64(buf[:8], uint64(len(o.t2s)))
	data = append(data, buf[:8]...)
	for i := range o.t2s {
		o := &o.t2s[i]
		{
			sub, err := o.MarshalBinary()
			if err != nil {
				return nil, err
			}
			binary.LittleEndian.PutUint64(buf[:8], uint64(len(sub)))
			data = append(data, buf[:8]...)
			data = append(data, sub...)
		}
	}
	binary.LittleEndian.PutUint64(buf[:8], uint64(len(o.t2ptrs)))
	data = append(data, buf[:8]...)
	for i := range o.t2ptrs {
		o := o.t2ptrs[i]
		{
			v := *o
			{
				sub, err := v.MarshalBinary()
				if err != nil {
					return nil, err
				}
				binary.LittleEndian.PutUint64(buf[:8], uint64(len(sub)))
				data = append(data, buf[:8]...)
				data = append(data, sub...)
			}
		}
	}
	binary.LittleEndian.PutUint64(buf[:8], math.Float64bits(o.data.f64))
	data = append(data, buf[:8]...)
	binary.LittleEndian.PutUint16(buf[:2], uint16(o.myU16))
	data = append(data, buf[:2]...)
	return data, err
}

// UnmarshalBinary implements encoding.BinaryUnmarshaler
func (o *T1) UnmarshalBinary(data []byte) (err error) {
	switch data[i] {
	case 0:
		o.b = false
	default:
		o.b = true
	}
	data = data[1:]
	o.u = uint(binary.LittleEndian.Uint64(data[:8]))
	data = data[8:]
	o.u8 = uint8(data[0])
	data = data[1:]
	o.u16 = uint16(binary.LittleEndian.Uint16(data[:2]))
	data = data[2:]
	o.u32 = uint32(binary.LittleEndian.Uint32(data[:4]))
	data = data[4:]
	o.u64 = uint64(binary.LittleEndian.Uint64(data[:8]))
	data = data[8:]
	o.i = int(binary.LittleEndian.Uint64(data[:8]))
	data = data[8:]
	o.i8 = int8(data[0])
	data = data[1:]
	o.i16 = int16(binary.LittleEndian.Uint16(data[:2]))
	data = data[2:]
	o.i32 = int32(binary.LittleEndian.Uint32(data[:4]))
	data = data[4:]
	o.i64 = int64(binary.LittleEndian.Uint64(data[:8]))
	data = data[8:]
	o.f32 = float32(math.Float32frombits(binary.LittleEndian.Uint32(data[:4])))
	data = data[4:]
	o.f64 = float64(math.Float64frombits(binary.LittleEndian.Uint64(data[:8])))
	data = data[8:]
	o.c64 = complex64(complex(math.Float32frombits(binary.LittleEndian.Uint32(data[:4])), math.Float32frombits(binary.LittleEndian.Uint32(data[4:8]))))
	data = data[8:]
	o.c128 = complex128(complex(math.Float64frombits(binary.LittleEndian.Uint64(data[:8])), math.Float64frombits(binary.LittleEndian.Uint64(data[8:16]))))
	data = data[16:]
	{
		n := int(binary.LittleEndian.Uint64(data[:8]))
		data = data[8:]
		o.str = string(data[:n])
		data = data[n:]
	}
	o.rune = rune(binary.LittleEndian.Uint32(data[:4]))
	data = data[4:]
	{
		n := int(binary.LittleEndian.Uint64(data[:8]))
		o.bs = make([]byte, n)
		data = data[8:]
		o.bs = append(o.bs, data[:n]...)
		data = data[n:]
	}
	for i := range o.arri64 {
		o.arri64[i] = int64(binary.LittleEndian.Uint64(data[:8]))
		data = data[8:]
	}
	for i := range o.arrTime {
		oi := &o.arrTime[i]
		{
			n := int(binary.LittleEndian.Uint64(data[:8]))
			data = data[8:]
			err = oi.UnmarshalBinary(data[:n])
			if err != nil {
				return err
			}
			data = data[n:]
		}
	}
	{
		n := int(binary.LittleEndian.Uint64(data[:8]))
		o.slii64 = make([]int64, n)
		data = data[8:]
		for i := range o.slii64 {
			o.slii64[i] = int64(binary.LittleEndian.Uint64(data[:8]))
			data = data[8:]
		}
	}
	{
		n := int(binary.LittleEndian.Uint64(data[:8]))
		o.sliTime = make([]time.Time, n)
		data = data[8:]
		for i := range o.sliTime {
			oi := &o.sliTime[i]
			{
				n := int(binary.LittleEndian.Uint64(data[:8]))
				data = data[8:]
				err = oi.UnmarshalBinary(data[:n])
				if err != nil {
					return err
				}
				data = data[n:]
			}
		}
	}
	{
		var v int64
		v = int64(binary.LittleEndian.Uint64(data[:8]))
		data = data[8:]
		o.ptri64 = &v

	}
	{
		n := int(binary.LittleEndian.Uint64(data[:8]))
		data = data[8:]
		err = o.t2.UnmarshalBinary(data[:n])
		if err != nil {
			return err
		}
		data = data[n:]
	}
	{
		n := int(binary.LittleEndian.Uint64(data[:8]))
		o.t2s = make([]T2, n)
		data = data[8:]
		for i := range o.t2s {
			oi := &o.t2s[i]
			{
				n := int(binary.LittleEndian.Uint64(data[:8]))
				data = data[8:]
				err = oi.UnmarshalBinary(data[:n])
				if err != nil {
					return err
				}
				data = data[n:]
			}
		}
	}
	{
		n := int(binary.LittleEndian.Uint64(data[:8]))
		o.t2ptrs = make([]*T2, n)
		data = data[8:]
		for i := range o.t2ptrs {
			var oi T2
			{
				var v T2
				{
					n := int(binary.LittleEndian.Uint64(data[:8]))
					data = data[8:]
					err = v.UnmarshalBinary(data[:n])
					if err != nil {
						return err
					}
					data = data[n:]
				}
				oi = &v

			}
			o.t2ptrs[i] = oi
		}
	}
	o.data.f64 = float64(math.Float64frombits(binary.LittleEndian.Uint64(data[:8])))
	data = data[8:]
	o.myU16 = U16(binary.LittleEndian.Uint16(data[:2]))
	data = data[2:]
	_ = data
	return err
}

// MarshalBinary implements encoding.BinaryMarshaler
func (o *T2) MarshalBinary() (data []byte, err error) {
	var buf [8]byte
	binary.LittleEndian.PutUint64(buf[:8], uint64(o.ID))
	data = append(data, buf[:8]...)
	return data, err
}

// UnmarshalBinary implements encoding.BinaryUnmarshaler
func (o *T2) UnmarshalBinary(data []byte) (err error) {
	o.ID = int64(binary.LittleEndian.Uint64(data[:8]))
	data = data[8:]
	_ = data
	return err
}

// MarshalBinary implements encoding.BinaryMarshaler
func (o *T3) MarshalBinary() (data []byte, err error) {
	var buf [8]byte
	{
		sub, err := o.Time.MarshalBinary()
		if err != nil {
			return nil, err
		}
		binary.LittleEndian.PutUint64(buf[:8], uint64(len(sub)))
		data = append(data, buf[:8]...)
		data = append(data, sub...)
	}
	return data, err
}

// UnmarshalBinary implements encoding.BinaryUnmarshaler
func (o *T3) UnmarshalBinary(data []byte) (err error) {
	{
		n := int(binary.LittleEndian.Uint64(data[:8]))
		data = data[8:]
		err = o.Time.UnmarshalBinary(data[:n])
		if err != nil {
			return err
		}
		data = data[n:]
	}
	_ = data
	return err
}
